# create a .zsh directory if necessary !
if [[ ! -d $HOME/.zsh ]] then
    mkdir $HOME/.zsh
fi

## The directory to search for shell startup files (.zshrc, etc),
## if not $HOME.
ZDOTDIR=~/.zsh

## get keys working
case $TERM in 
    linux)
    bindkey "^[[2~" yank
    bindkey "^[[3~" delete-char
    bindkey "^[[5~" up-line-or-history ## PageUp
    bindkey "^[[6~" down-line-or-history ## PageDown
    bindkey "^[[1~" beginning-of-line
    bindkey "^[[4~" end-of-line
    bindkey "^[e" expand-cmd-path ## C-e for expanding path of typed command
    bindkey "^[[A" up-line-or-search ## up arrow for back-history-search
    bindkey "^[[B" down-line-or-search ## down arrow for fwd-history-search
    bindkey " " magic-space ## do history expansion on space
;;
    *xterm*|rxvt|(dt|k|E)term)
    bindkey "^[[2~" yank
    bindkey "^[[3~" delete-char
    bindkey "^[[5~" up-line-or-history ## PageUp
    bindkey "^[[6~" down-line-or-history ## PageDown
    bindkey "^[[7~" beginning-of-line
    bindkey "^[[8~" end-of-line
    bindkey "^[e" expand-cmd-path ## C-e for expanding path of typed command
    bindkey "^[[A" up-line-or-search ## up arrow for back-history-search
    bindkey "^[[B" down-line-or-search ## down arrow for fwd-history-search
    bindkey " " magic-space ## do history expansion on space
;;
esac

## (( ${+*} )) = if variable is set don't set it anymore
(( ${+USER} )) || export USER=$USERNAME
(( ${+HOSTNAME} )) || export HOSTNAME=$HOST
(( ${+EDITOR} )) || export EDITOR=`which vim`
(( ${+VISUAL} )) || export VISUAL=`which vim`
(( ${+FCEDIT} )) || export FCEDIT=`which vim`
(( ${+PAGER} )) || export PAGER=`which less`
#(( ${+MAILCALL} )) || export MAILCALL='*** NEW MAIL ***' ## new mail warning
(( ${+LESSCHARSET} )) || export LESSCHARSET='latin1' ## charset for pager
#(( ${+LESSOPEN} )) || export LESSOPEN='|lesspipe.sh %s'
#(( ${+MOZILLA_HOME} )) || export MOZILLA_HOME='/usr/lib/netscape' ## EDIT ##
#(( ${+MOZILLA_NO_ASYNC_DNS} )) || export MOZILLA_NO_ASYNC_DNS='True'
#(( ${+NNTPSERVER} )) || export NNTPSERVER=''  ## news server ## EDIT ##
(( ${+CC} )) || export CC='gcc' ## or egcs or whatever

## This allows incremental completion of a word.
## After starting this command, a list of completion
## choices can be shown after every character you
## type, which you can delete with ^h or DEL.
## RET will accept the completion so far.
## You can hit TAB to do normal completion, ^g to            
## abort back to the state when you started, and ^d to list the matches.
autoload -U incremental-complete-word
zle -N incremental-complete-word
bindkey "^Xi" incremental-complete-word ## C-x-i

## This function allows you type a file pattern,
## and see the results of the expansion at each step.
## When you hit return, they will be inserted into the command line.
autoload -U insert-files
zle -N insert-files
bindkey "^Xf" insert-files ## C-x-f

# -----/ Some colors /-----
export red=$'%{\e[0;31m%}'
export RED=$'%{\e[1;31m%}'
export green=$'%{\e[0;32m%}'
export GREEN=$'%{\e[1;32m%}'
export blue=$'%{\e[0;34m%}'
export BLUE=$'%{\e[1;34m%}'
export purple=$'%{\e[0;35m%}'
export PURPLE=$'%{\e[1;35m}'
export cyan=$'%{\e[0;36m%}'
export CYAN=$'%{\e[1;36m}'
export WHITE=$'%{\e[1;37m}'
export white=$'%{\e[0;37m}'
export yellow=$'%{\e[0;33m%}'
export CLEAR=$'%{\e[0m%}'

## Loading colors
autoload -U colors
colors

## csh compatibility
setenv () { typeset -x "${1}${1:+=}${(@)argv[2,$#]}" }

# Trouver la couleur de l'utilisateur
if [[ $UID == 0 ]]; then
	user_color="red"
    user_prompt="#"
else
	user_color="white"
    user_prompt="$"
fi;

# define your colors here (i hate white background)
path_color="magenta"
date_color="yellow"
date_crochet='cyan'
path_crochet='blue'
arrobase_color="white"
sep_color="cyan"

# Format
date_format="%H:%M:%S"

# PS Format:
# [ ~ ]
# user@host » ; [ Day time(hh:mm:ss) ]

#date="${cyan}[%{$fg_bold[$date_color]%}%D{$date_format}${cyan}]%{$fg_bold[$user_color]%}"
#host="%{$fg_bold[$path_crochet]%}[ %{$reset_color%}% %4c%1v %{$fg_bold[$path_crochet]%}]${CLEAR}
#%{$fg_bold[$user_color]%}%n%{$fg_bold[$arrobase_color]%}@%m $user_prompt%{$fg_bold[$date_color]%} » %{$fg_bold[$user_color]%}"
#cpath="%B%{$fg_bold[$path_color]%}%~%b"
#end="%{$reset_color%}%"

date="${cyan}[%{$fg[$date_color]%}%D{$date_format}${cyan}]%{$fg[$user_color]%}"
host="%{$fg[$path_crochet]%}[ %{$reset_color%}% %4c%1v %{$fg[$path_crochet]%}]${CLEAR}
%{$fg[$user_color]%}%n@%m $user_prompt %{$fg[$date_color]%}»%{$fg[$user_color]%} "
end="%{$reset_color%}%"

PS1="$host"
RPS1="$date" 

## Or just choose one
#PS1=$'%{\e[0;36m%}%n%{\e[0m%}:%{\e[0;31m%}%3~%{\e[0m%}%# ' ## user:~%
#PS1=$'%{\e[0;36m%}%n%{\e[0m%}:%{\e[0;31m%}%3~%{\e[0m%}%B>%b ' ## user:~>
#PS1='%B[%b%n%B:%b%~%B]%b$ ' ## [user:~]$
#PS1=$'%{\e[0;36m%}%n%{\e[0m%}:%20<..<%~%B>%b ' ## user:..c/vim-common-6.0>
#PS1=$'%{\e[0;36m%}%#%{\e[0m%} ';RPS1=$'%{\e[0;31m%}%~%{\e[0m%}' ## % ; ~
#PS1=$'%{\e[0;36m%}%n%{\e[0m%}%{\e[0;31m%}%#%{\e[0m%} ';RPS1=$'%{\e[0;31m%}%~%{\e[0m%}' ## user% ; ~
#PS1='%# ';RPS1='%B%~%b' ## % ; ~ : no colors
#PS1='%n@%m:%B%~%b> ' ## user@host:~> : no colors

## don't ask me 'do you wish to see all XX possibilities' before menu selection
LISTPROMPT=''

## SPROMPT - the spelling prompt
SPROMPT=$'zsh: correct \'%{\e[1;31m%}%R%{\e[0m%}\' to \'%{\e[1;32m%}%r%{\e[0m%}\' ? ([Y]es/[N]o/[E]dit/[A]bort) '

## set colors for GNU ls ; set this to right file
which dircolors > /dev/null
if [ $? -eq 0 ]; then
    eval `dircolors`
    alias ls='ls --color=auto'
else
    ## dircolors not availaible, try gdircolors
    which gdircolors > /dev/null
    if [ $? -eq 0 ]; then
        eval `gdircolors -b`
        alias ls='gls --color=auto'
    else    
        ## We need LS_COLORS to be set for use by zsh
        export LS_COLORS="no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.png=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:"
        ## GNU ls not available, using other one.
        case $(uname) in
            FreeBSD)
                export BLOCKSIZE=K
                export CLICOLOR=enable
                autoload -U is-at-least
                if is-at-least 4.6 $OSTYPE ; then
                    # new style
                    LSCOLORS="dxfxBxcxbxegedabagacad"
                else
                    # Old Style
                    LSCOLORS="3x5x2x3x1x464301060203"
                fi
                export LS_COLORS
            ;;
            OpenBSD|NetBSD|Darwin|SunOS)
                alias ls='ls -F'
            ;;
        esac
    fi
fi

##################################################
# PROLOGUE

# no core dumps
# ulimit -c 0

# file creation mask
umask 022

# auto spellchecking
setopt correct
setopt correctall

# ignore duplicated entrys in history and with trailing spaces
setopt histignoredups
setopt histignorespace

# only exit or logout to leave zsh
#setopt ignoreeof

# let you type comment's
setopt interactivecomments

# now you can negates pattern [ ls -d ^*.c ]
setopt extendedglob

## turn on full featured completion (minimal needs: zsh3.1)
if [[ "$ZSH_VERSION" == (3.1|4)* ]]; then
    autoload -U compinit
    compinit -C
else
    print "Advanced completion system not found; ignoring zstyle settings."
    function zstyle { }
fi

# frequently used hosts
## common hostnames
hosts=( $(</etc/hosts) )
hosts=($hosts)
zstyle ':completion:*' hosts $hosts

# Add the hostnames from ~/.ssh/know_hosts to hosts (used by all commands that complete on hosts)
if [[ -f $HOME/.ssh/known_hosts ]] ; then
    local _myhosts
    _myhosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[0-9]*}%%\ *}%%,*})
    zstyle ':completion:*' hosts $_myhosts
fi

# nice prompt on the left side ...
#PROMPT=$'%{\e[01;34m%}\%!,%l,%?,%{\e[01;33m%}\%1~ %{\e[01;32m%}$%{\e[0m%} '
# ... and a another on the right side! ;-)
#RPROMPT=$'%{\e[01;34m%}\%m%{\e[0m%}'

# of course
EDITOR=vim

# favorite pager (give more information)
PAGER='less -M'

# work with history mechanism
## The file to save the history in when an interactive shell exits.
## If unset, the history is not saved.
HISTFILE=${HOME}/.zsh/history

## The maximum number of events stored in the internal history list.
HISTSIZE=2000

## The maximum number of history events to save in the history file.
SAVEHIST=1000

## maximum size of the directory stack.
DIRSTACKSIZE=20

## watch for my friends
## An array (colon-separated list) of login/logout events to report.
## If it contains the single word `all', then all login/logout events
## are reported.  If it contains the single word `notme', then all
## events are reported as with `all' except $USERNAME.
## An entry in this list may consist of a username,
## an `@' followed by a remote hostname,
## and a `%' followed by a line (tty).
#watch=( $(<~/.zsh/friends) )  ## watch for people in $HOME/.friends file
watch=(notme)  ## watch for everybody but me
LOGCHECK=60  ## check every ... seconds for login/logout activity

## The format of login/logout reports if the watch parameter is set.
## Default is `%n has %a %l from %m'.
## Recognizes the following escape sequences:
## %n = name of the user that logged in/out.
## %a = observed action, i.e. "logged on" or "logged off".
## %l = line (tty) the user is logged in on.
## %M = full hostname of the remote host.
## %m = hostname up to the first `.'.
## %t or %@ = time, in 12-hour, am/pm format.
## %w = date in `day-dd' format.
## %W = date in `mm/dd/yy' format.
## %D = date in `yy-mm-dd' format.

WATCHFMT="$fg_bold[cyan]%n $fg[white]%a %l from $fg_bold[magenta]%M $fg[white]at $fg_bold[yellow]%T."

######################################################
## ALIASES #####
################
alias   a="alias"
a       l="ls -l --color"
a       ll="ls -l --color"
a       m='mutt'
a       sdr='screen -dr'
a       doaclean="rm -f *.*~"
a       banner='figlet'
# a       updateZshrc='wget http://*******.net/zshrc ; mv -f zshrc ~/.zshrc ; . ~/.zshrc '

######################################################
## DIR #########
################

export PATH=$PATH:~/scripts:$HOME/local/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/local/lib
export MANPATH=$MANPATH:$HOME/local/man

#####################################################
## KEYS #######
###############

# Common standard keypad and cursor
bindkey    "^[[2~" yank
bindkey    "^[[3~" delete-char

# History completion on pgup and pgdown
autoload -U history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^[[5~" history-beginning-search-backward-end
bindkey "^[[6~" history-beginning-search-forward-end

if [[ "$TERM" == "xterm" ]] then
    bindkey    "^[2;5~" yank
    bindkey    "^[3;5~" delete-char
    bindkey    "^[5;5~" up-history
    bindkey    "^[6;5~" down-history
fi
bindkey    "^[[C" forward-char
bindkey    "^[[D" backward-char
bindkey    "^[[A" up-history
bindkey    "^[[B" down-history

# Avoid network problems
#   ... \177 (ASCII-DEL) and \010 (ASCII-BS)
#       do `backward-delete-char'
# Note: `delete-char' is maped to \033[3~
#       Therefore xterm's responce on pressing
#       key Delete or KP-Delete should be
#       \033[3~ ... NOT \177
bindkey    "^?" backward-delete-char
bindkey    "^H" backward-delete-char

# Home and End
if [[ "$TERM" == "xterm" ]] then
    # Normal keypad and cursor of xterm
    bindkey    "^[[1~" history-search-backward
    bindkey    "^[[4~" set-mark-command
    bindkey    "^[[H" beginning-of-line
    bindkey    "^[[F" end-of-line
    # Home and End of application keypad and cursor of xterm
    bindkey    "^[OH" beginning-of-line
    bindkey    "^[OF" end-of-line
    bindkey    "^[O5H" beginning-of-line
    bindkey    "^[O5F" end-of-line
else
if [[ "$TERM" == "kvt" ]] then
    bindkey    "^[[1~" history-search-backward
    bindkey    "^[[4~" set-mark-command
    bindkey    "^[OH" beginning-of-line
    bindkey    "^[OF" end-of-line
else
    # TERM=linux or console
    bindkey    "^[[1~" beginning-of-line
    bindkey    "^[[4~" end-of-line
fi
fi

# Application keypad and cursor of xterm
if [[ "$TERM" == "xterm" ]] then
    bindkey    "^[OD" backward-char
    bindkey    "^[OC" forward-char
    bindkey    "^[OA" up-history
    bindkey    "^[OB" down-history
    # DEC keyboard KP_F1 - KP_F4
    bindkey -s "^[OP" "^["
    bindkey    "^[OQ" undo
    bindkey    "^[OR" undefined-key  
    bindkey    "^[OS" kill-line
fi
if [[ "$TERM" == "gnome" ]] then
    # or gnome terminal F1 - F4
    bindkey -s "^[OP" "^["
    bindkey    "^[OQ" undo
    bindkey    "^[OR" undefined-key  
    bindkey    "^[OS" kill-line
fi
# Function keys F1 - F12
if [[ "$TERM" == "linux" ]] then
    # On console the first five function keys
    bindkey    "^[[[A" undefined-key
    bindkey    "^[[[B" undefined-key
    bindkey    "^[[[C" undefined-key
    bindkey    "^[[[D" undefined-key
    bindkey    "^[[[E" undefined-key
else
    # The first five standard function keys
    bindkey    "^[[11~" undefined-key
    bindkey    "^[[12~" undefined-key
    bindkey    "^[[13~" undefined-key
    bindkey    "^[[14~" undefined-key
    bindkey    "^[[15~" undefined-key
fi
bindkey    "^[[17~" undefined-key
bindkey    "^[[18~" undefined-key
bindkey    "^[[19~" undefined-key
bindkey    "^[[20~" undefined-key
bindkey    "^[[21~" undefined-key
# Note: F11, F12 are identical with Shift_F1 and Shift_F2
bindkey    "^[[23~" undefined-key
bindkey    "^[[24~" undefined-key

# Shift Function keys F1  - F12
#      identical with F11 - F22
#
# bindkey   "^[[23~" undefined-key
# bindkey   "^[[24~" undefined-key
bindkey    "^[[25~" undefined-key
bindkey    "^[[26~" undefined-key
# DEC keyboard: F15=^[[28~ is Help
bindkey    "^[[28~" undefined-key
# DEC keyboard: F16=^[[29~ is Menu
bindkey    "^[[29~" undefined-key
bindkey    "^[[31~" undefined-key
bindkey    "^[[32~" undefined-key
bindkey    "^[[33~" undefined-key
bindkey    "^[[34~" undefined-key
if [[ "$TERM" == "xterm" ]] then
    # Not common
    bindkey    "^[[35~" undefined-key
    bindkey    "^[[36~" undefined-key
fi

if [[ "$TERM" == "xterm" ]] then
    # Application keypad and cursor of xterm
    # with NumLock ON
    #
    # Operators
    bindkey -s "^[Oo" "/"
    bindkey -s "^[Oj" "*"
    bindkey -s "^[Om" "-"
    bindkey -s "^[Ok" "+"
    bindkey -s "^[Ol" ","
    bindkey -s "^[OM" "\n"
    bindkey -s "^[On" "."
    # Numbers
    bindkey -s "^[Op" "0"
    bindkey -s "^[Oq" "1"
    bindkey -s "^[Or" "2"
    bindkey -s "^[Os" "3"
    bindkey -s "^[Ot" "4"
    bindkey -s "^[Ou" "5"
    bindkey -s "^[Ov" "6"
    bindkey -s "^[Ow" "7"
    bindkey -s "^[Ox" "8"
    bindkey -s "^[Oy" "9"
fi

#  EMACS line editing
if [[ "$ZSHEDIT" == "emacs" ]] then 
    # ... xterm application cursor
    if [[ "$TERM" == "xterm" ]] then
bindkey    "^[^[OD" backward-word
bindkey    "^[^[OC" forward-word
bindkey    "^[^[OA" up-history
bindkey    "^[^[OB" down-history
bindkey    "^^[OD" backward-char
bindkey    "^^[OC" forward-char
bindkey    "^^[OA" up-history
bindkey    "^^[OB" down-history
    fi
    # Standard cursor
    bindkey    "^[^[[D" backward-word
    bindkey    "^[^[[C" forward-word
    bindkey    "^[^[[A" up-history
    bindkey    "^[^[[B" down-history
    bindkey    "^^[[D" backward-char
    bindkey    "^^[[C" forward-char
    bindkey    "^^[[A" up-history
    bindkey    "^^[[B" down-history
fi
